/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a user-ownership model with group-based access control for collaborative features.
 *
 * Data Structure:
 * - /users/{userId}: Stores public user profiles.
 * - /users/{userId}/fcmTokens/{tokenId}: Stores FCM tokens for user devices.
 * - /users/{userId}/notifications/{notificationId}: Stores notifications for a user.
 * - /players/{playerId}: Stores player data, linked to a group.
 * - /players/{playerId}/ovrHistory/{historyId}: Stores OVR history for players.
 * - /groups/{groupId}: Stores group data.
 * - /matches/{matchId}: Stores match data, linked to a group.
 * - /matches/{matchId}/assignments/{assignmentId}: Stores evaluation assignments for matches.
 * - /matches/{matchId}/selfEvaluations/{userId}: Stores self-evaluations for matches.
 * - /matches/{matchId}/messages/{messageId}: Stores chat messages for matches.
 * - /evaluations/{evaluationId}: Stores individual evaluation records.
 *
 * Key Security Decisions:
 * - User profiles are readable by anyone but only writable by the user themselves.
 * - FCM tokens and notifications are only accessible to the owning user.
 * - Players, matches, and evaluations are linked to groups, and access is controlled by group membership.
 * - Chat messages within a match are accessible to match participants.
 * - All write operations require authentication.
 * - Data validation is minimal in this prototyping phase, focusing on ownership and relational integrity.
 *
 * Denormalization for Authorization:
 * - Players and Matches have `ownerUid` and `groupId` fields for authorization. This avoids needing extra reads to determine ownership or group membership.
 * - SelfEvaluations are keyed by `userId` for easy access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows anyone to read user profiles, but only the user can modify their own profile.
     * @path /users/{userId}
     * @allow (get, list): if true
     * @allow (create, update, delete): if request.auth.uid == userId
     * @deny (create, update, delete): if request.auth.uid != userId
     * @principle Enforces document ownership for writes; public read access.
     */
    match /users/{userId} {
      allow get, list: if true;
      allow create: if request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to FCM tokens to the owning user.
     * @path /users/{userId}/fcmTokens/{tokenId}
     * @allow (create, get, list, update, delete): if request.auth.uid == userId
     * @deny (create, get, list, update, delete): if request.auth.uid != userId
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/fcmTokens/{tokenId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to notifications to the owning user.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (create, get, list, update, delete): if request.auth.uid == userId
     * @deny (create, get, list, update, delete): if request.auth.uid != userId
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows access to player data based on group membership and ownership.
     * @path /players/{playerId}
     * @allow (get, list): if true
     * @allow (create): if request.auth.uid == request.resource.data.ownerUid
     * @allow (update, delete): if isExistingOwner(playerId)
     * @deny (create): if request.auth.uid != request.resource.data.ownerUid
     * @principle Enforces group-based access control and ownership.
     */
    match /players/{playerId} {
      allow get, list: if true;
      allow create: if request.auth.uid == request.resource.data.ownerUid;
      allow update: if isExistingOwner(playerId);
      allow delete: if isExistingOwner(playerId);
    }

     /**
     * @description Restricts access to OVR history to the owning player.
     * @path /players/{playerId}/ovrHistory/{historyId}
     * @allow (create, get, list, update, delete): if request.auth.uid == playerId
     * @deny (create, get, list, update, delete): if request.auth.uid != playerId
     * @principle Restricts access to a user's own data tree.
     */
    match /players/{playerId}/ovrHistory/{historyId} {
      allow get, list: if isOwner(playerId);
      allow create: if isOwner(playerId);
      allow update: if isExistingOwner(playerId);
      allow delete: if isExistingOwner(playerId);
    }

    /**
     * @description Allows group owners to manage group data.
     * @path /groups/{groupId}
     * @allow (get, list): if true
     * @allow (create): if request.resource.data.ownerUid == request.auth.uid
     * @allow (update, delete): if isGroupOwner(groupId)
     * @deny (create): if request.resource.data.ownerUid != request.auth.uid
     * @principle Enforces group ownership for management.
     */
    match /groups/{groupId} {
      allow get, list: if true;
      allow create: if request.resource.data.ownerUid == request.auth.uid;
      allow update: if isGroupOwner(groupId);
      allow delete: if isGroupOwner(groupId);
    }

    /**
     * @description Allows group members to read match data, and the owner to manage it.
     * @path /matches/{matchId}
     * @allow (get, list): if true
     * @allow (create): if request.resource.data.ownerUid == request.auth.uid
     * @allow (update, delete): if isMatchOwner(matchId)
     * @deny (create): if request.resource.data.ownerUid != request.auth.uid
     * @principle Enforces group-based access and ownership.
     */
    match /matches/{matchId} {
      allow get, list: if true;
      allow create: if request.resource.data.ownerUid == request.auth.uid;
      allow update: if isMatchOwner(matchId);
      allow delete: if isMatchOwner(matchId);
    }

    /**
     * @description Allows access to evaluation assignments within a match to match participants.
     * @path /matches/{matchId}/assignments/{assignmentId}
     * @allow (get, list): if true;
     * @allow create: if get(/databases/$(database)/documents/matches/$(matchId)).data.playerUids.hasAny([request.auth.uid]);
     * @allow update: if get(/databases/$(database)/documents/matches/$(matchId)).data.playerUids.hasAny([request.auth.uid]) && resource != null;
     * @allow delete: if get(/databases/$(database)/documents/matches/$(matchId)).data.playerUids.hasAny([request.auth.uid]) && resource != null;
     * @principle Restricts access to match participants using get() call.
     */
    match /matches/{matchId}/assignments/{assignmentId} {
      allow get, list: if true;
      allow create: if get(/databases/$(database)/documents/matches/$(matchId)).data.playerUids.hasAny([request.auth.uid]);
      allow update: if get(/databases/$(database)/documents/matches/$(matchId)).data.playerUids.hasAny([request.auth.uid]) && resource != null;
      allow delete: if get(/databases/$(database)/documents/matches/$(matchId)).data.playerUids.hasAny([request.auth.uid]) && resource != null;
    }

    /**
     * @description Allows a user to create/update their own self-evaluation for a match.
     * @path /matches/{matchId}/selfEvaluations/{userId}
     * @allow (create, get, list, update, delete): if request.auth.uid == userId
     * @deny (create, get, list, update, delete): if request.auth.uid != userId
     * @principle Restricts access to a user's own self-evaluation.
     */
    match /matches/{matchId}/selfEvaluations/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows match participants to read chat messages.
     * @path /matches/{matchId}/messages/{messageId}
     * @allow (get, list): if get(/databases/$(database)/documents/matches/$(matchId)).data.playerUids.hasAny([request.auth.uid])
     * @allow (create): if get(/databases/$(database)/documents/matches/$(matchId)).data.playerUids.hasAny([request.auth.uid]);
     * @allow update: if false;
     * @allow delete: if false;
     * @principle Restricts read access to match participants using get() call.
     */
    match /matches/{matchId}/messages/{messageId} {
      allow get, list: if get(/databases/$(database)/documents/matches/$(matchId)).data.playerUids.hasAny([request.auth.uid]);
      allow create: if get(/databases/$(database)/documents/matches/$(matchId)).data.playerUids.hasAny([request.auth.uid]);
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows read/write access to evaluation data to match participants.
     * @path /evaluations/{evaluationId}
     * @allow (get, list): if true;
     * @allow create: if true;
     * @allow update: if true;
     * @allow delete: if true;
     * @principle Allows everyone to read the evaluations.
     */
    match /evaluations/{evaluationId} {
      allow get, list: if true;
      allow create: if true;
      allow update: if true;
      allow delete: if true;
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return request.auth.uid == userId && resource != null;
    }

    function isGroupOwner(groupId) {
      return isSignedIn() && get(/databases/$(database)/documents/groups/$(groupId)).data.ownerUid == request.auth.uid;
    }

     function isMatchOwner(matchId) {
      return isSignedIn() && get(/databases/$(database)/documents/matches/$(matchId)).data.ownerUid == request.auth.uid;
    }
  }
}